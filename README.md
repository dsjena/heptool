# HEP Tools

Software tool usually used in HEP and EHEP community. This list is not the complete list of all software. However, this list are gradually evolving software list. It all started for students to keep very basic level of introduction and particularly towards the installation where student face lot of issues. 

I invite every one to share the tools/script which can help to student for the same. 

A paragraph of introduction have been directly taken from the respective pages without modification (without disturbing the actual information). Thus author doesn't have any claim of authership or any kind of credit out of this. This colleciton is made purely for the educational purpose and for the pupose of outreach to students.  

# autotools 

source https://www.lrde.epita.fr/~adl/autotools.html

If you are new to Automake, maybe you know that it is part of a set of tools called The Autotools. Maybe you’ve already delved into a package full of files named configure, configure.ac, Makefile.in, Makefile.am, aclocal.m4, …, some of them claiming to be generated by Autoconf or Automake. But the exact purpose of these files and their relations is probably fuzzy. The goal of this chapter is to introduce you to this machinery, to show you how it works and how powerful it is. If you’ve never installed or seen such a package, do not worry: this chapter will walk you through it.

If you need some teaching material, more illustrations, or a less automake-centered continuation, some slides for this introduction are available in Alexandre Duret-Lutz’s Autotools Tutorial. This chapter is the written version of the first part of his tutorial. 

# boost 

source https://www.boost.org/

Boost provides free peer-reviewed portable C++ source libraries.

We emphasize libraries that work well with the C++ Standard Library. Boost libraries are intended to be widely useful, and usable across a broad spectrum of applications. The Boost license encourages the use of Boost libraries for all users with minimal restrictions.

We aim to establish "existing practice" and provide reference implementations so that Boost libraries are suitable for eventual standardization. Beginning with the ten Boost Libraries included in the Library Technical Report (TR1) and continuing with every release of the ISO standard for C++ since 2011, the C++ Standards Committee has continued to rely on Boost as a valuable source for additions to the Standard C++ Library.

# cctools 

source https://github.com/cooperative-computing-lab/cctools

The Cooperative Computing Tools (cctools) is a software
package for enabling large scale distributed computing
on clusters, clouds, and grids.  It is used primarily for
attacking large scale problems in science and engineering.

You can read more about this software at:
   http://ccl.cse.nd.edu/software

The software is developed by members of the Cooperative
Computing Lab at the University of Notre Dame, led by
Prof. Douglas Thain.  The file CREDITS lists the many
people that have contributed to the software over the years.


# cgal 
source https://www.cgal.org/

The Computational Geometry Algorithm Library (CGAL) is a software 
library written in C++. It provides easy access to the efficient 
geometric algorithm and has a wide application ranging from computer 
graphics and robotics to medical imaging and geographic information system.

# clhep 
source https://gitlab.cern.ch/CLHEP/CLHEP

A Class Library for High Energy Physics (CLHEP) is a C++ based library that provides
a set of utility classes specific to HEP community such as random generators, physics 
vectors, geometry and linear algebra. 

# cmake 
source https://github.com/Kitware/CMake

CMake is a open-source tool to designed to build, test and package a software
using a compiler-independent method 
# geant3 
source http://root.cern.ch/git/geant3.git

GEANT is an acronym for GEometry ANd Tracking. It is a detector simulation software 
primarily written in FORTRAN. It is designed to study the passage of particle through 
matter using Monte Carlo methods. It include utilities to simulate detector geometry, 
detector response, tracking of particles in the deetector material etc.
# geant3 
source http://root.cern.ch/git/geant3.git
# geant4 
source https://geant4.web.cern.ch/
GEANT4 is a rewrite of GEANT3 into an object oriented programming language (C++)
# misc 

Some miscellenous collection of script

source www.satyajitjena.in


# pythia6 
source http://home.thep.lu.se/~torbjorn/pythiaaux/past.html
PYTHIA6 is a FORTRAN-based event generator that is used to simulate multiparticle production in 
high energy hadronic as well as heavy ion collision. It generate events in as much
detail as experimentally observable ones, within the bounds of our current understanding
of the underlying physics.

# pythia8 
source http://home.thep.lu.se/~torbjorn/pythia82html/Welcome.html
PYTHIA8 is simply the C++ version of PYTHIA6 with some additional physics inputs.
# genie-mc 
source http://www.genie-mc.org/
GENIE is a Monte Carlo event generator used primarily for neutrino events. Prediction from GENIE events
are being used as reference point by almost all modern neutrino physics experiments.
# nuance 
source http://neutrino.phy.duke.edu/nuance-format/
nuance is a software package developed to simulate the neutrino interactions. This 
program can generates different final states for neutral current and charged current processes. 
# hijing 
source https://arxiv.org/abs/nucl-th/9502021
Heavy-Ion Jet INteraction Generator (HIJING) is a Monte Carlo event generator based on QCD-inspired models
for multiple jet production. It is primarily used to study jet and associated particle production in high energy collisions
involving hadrons and/or heavy-ion. 

# RooUnfold 
source http://hepunx.rl.ac.uk/~adye/software/unfold/RooUnfold.html
RooUnfold is a ROOT Unfolding framework used to remove known uncertainities
arising from systematic biases, measurement resolution so as to study the "true" distribution.
# urqmd 
source https://urqmd.org/
Ultra relativistic Quantum Molecular Dynamics (UrQMD) is an event generator to simulate pp, pA and AA collision. It is a microscopic transport theory based simulation used for studying a wide variety of heavy ion related effects ranging from multifragmentation and collective flow to particle production and correlations. 
# python 
source https://www.python.org/
Python is an interpreted, object oriented, high-level programming language. 
# pyroot 

source https://root.cern.ch/pyroot

PyROOT is a Python extension module that allows the user to interact with any ROOT class from the Python interpreter. This is done generically using the ROOT dictionary, therefore there is no need to generate any Python wrapper code to include new ROOT classes. At the same time PyROOT offers the possibility to execute and evaluate any Python command or start a Python shell from the ROOT/CLING prompt. Further details are available in the PyROOT section of the Users' Guide.
Enabling PyROOT

All the instructions relative to the flags to configure ROOT can be found here. In this particular case, PyROOT is enabled by default: just make sure you have the Python header files on your machine.
More pythonistic PyROOT: rootpy

The generality with which PyROOT creates bindings based on dictionaries makes that it is close to the original C++, which is great for e.g. sharing documentation. However, where it is possible to do so automatically, e.g. for handling of container classes, "pythonizations" are available. If that is not enough for your needs, then check out the rootpy project for a more pythonistic PyROOT.
High performance PyROOT: cppyy

A new approach is based on cppyy, a run-time bindings generator like PyROOT for the PyPy project. It has both a CINT and a pure-Reflex back-end and is, depending on use, 50x-100x faster than PyROOT. A pre-installed version based on the CINT backend is available on /afs as pypyroot.


# Pythran 
source https://pythran.readthedocs.io/en/latest/

# docs 
source Document


# minerva 
source  Script related to minerva 


# root

source https://root.cern.ch/

A modular scientific software toolkit. It provides all the functionalities needed to deal with big data processing, statistical analysis, visualisation and storage. It is mainly written in C++ but integrated with other languages such as Python and R.
 

In the mid 1990’s, René Brun and Fons Rademakers had many years of experience developing interactive tools and simulation packages. They had lead successful projects such as PAW, PIAF, and GEANT, and they knew PAW the twenty-year-old FORTRAN libraries had reached their limits. Although still very popular, these tools could not scale up to the challenges offered by the Large Hadron Collider, where the data is a few orders of magnitude larger than anything seen before.

At the same time, computer science had made leaps of progress especially in the area of Object Oriented Design, and René and Fons were ready to take advantage of it.

ROOT was developed in the context of the NA49 experiment at CERN. NA49 has generated an impressive amount of data, around 10 Terabytes per run. This rate provided the ideal environment to develop and test the next generation data analysis.

ROOT was, and still is, developed in the “Bazaar style”, a term from the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a liberal, informal development style that heavily relies on the diverse and deep talent of the user community. The result is that physicists developed ROOT for themselves; this made it specific, appropriate, useful, and over time refined and very powerful. The development of ROOT is a continuous conversation between users and developers with the line between the two blurring at times and the users becoming co-developers.

When it comes to storing and mining large amount of data, physics plows the way with its Terabytes, but other fields and industry follow close behind as they acquiring more and more data over time. They are ready to use the true and tested technologies physics has invented. In this way, other fields and industries have found ROOT useful and they have started to use it also.

In the bazaar view, software is released early and frequently to expose it to thousands of eager co-developers to pound on, report bugs, and contribute possible fixes. More users find more bugs, because they stress the program in different ways. By now, after ten years, the age of ROOT is quite mature. Most likely, you will find the features you are looking for, and if you have found a hole, you are encouraged to participate in the dialog and post your suggestion or even implementation on the ROOT forum.


# cython 

source https://cython.org/

 Cython is an optimising static compiler for both the Python programming language and the extended Cython programming language (based on Pyrex). It makes writing C extensions for Python as easy as Python itself.

Cython gives you the combined power of Python and C to let you

    write Python code that calls back and forth from and to C or C++ code natively at any point.
    easily tune readable Python code into plain C performance by adding static type declarations, also in Python syntax.
    use combined source code level debugging to find bugs in your Python, Cython and C code.
    interact efficiently with large data sets, e.g. using multi-dimensional NumPy arrays.
    quickly build your applications within the large, mature and widely used CPython ecosystem.
    integrate natively with existing code and data from legacy, low-level or high-performance libraries and applications.

The Cython language is a superset of the Python language that additionally supports calling C functions and declaring C types on variables and class attributes. This allows the compiler to generate very efficient C code from Cython code. The C code is generated once and then compiles with all major C/C++ compilers in CPython 2.6, 2.7 (2.4+ with Cython 0.20.x) as well as 3.3 and all later versions. We regularly run integration tests against all supported CPython versions and their latest in-development branches to make sure that the generated code stays widely compatible and well adapted to each version. PyPy support is work in progress (on both sides) and is considered mostly usable since Cython 0.17. The latest PyPy version is always recommended here.

All of this makes Cython the ideal language for wrapping external C libraries, embedding CPython into existing applications, and for fast C modules that speed up the execution of Python code. 
